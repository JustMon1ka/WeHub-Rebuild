## Founding Service模块重构

重构前的模块文件夹结构：
```
FoundingService/
├── Controllers/
│   ├── DbTestController.cs       // 包含直接的数据库查询逻辑
│   ├── RecommendController.cs    // 依赖 Service
│   └── TopicsController.cs       // 包含直接的数据库查询逻辑
├── Models/
│   └── RecommendResult.cs
├── ORCLEUPDATER/                 // 独立的工具模块
│   ├── TestDataController.cs
│   └── TestDataService.cs        // 包含大量测试数据的 SQL
├── Services/
│   └── RecommendService.cs       // 核心业务类，包含连接创建、SQL查询、算法逻辑
└── Program.cs
```
可以看出，原本的结构比较扁平，Controller 和 Service 中混合了大量的 SQL 语句和数据库连接代码，缺乏清晰的分层。
重构后的文件夹结构：
```
FoundingService/
├── Controllers/                  // 【表现层】仅负责 HTTP 请求/响应
│   ├── RecommendController.cs    // 对应原 RecommendController
│   ├── TopicsController.cs       // 对应原 TopicsController
│   └── DbTestController.cs       // 对应原 DbTestController
│
├── Services/                     // 【业务层】负责业务编排、逻辑判断
│   ├── RecommendService.cs       // 负责推荐逻辑 (调用 Facade 和 Strategy)
│   ├── TopicService.cs           // 负责话题统计逻辑 (原 TopicsController 中的逻辑)
│   └── DatabaseToolService.cs    // 负责数据库元数据查询 (原 DbTestController 中的逻辑)
│
├── Facades/                      // 【外观层】(原 Repositories) 封装 SQL 和 ADO.NET
│   ├── Interfaces/               // 定义接口，方便依赖注入和 Mock 测试
│   │   ├── IRecommendDbFacade.cs // 推荐相关 SQL 接口
│   │   ├── ITopicDbFacade.cs     // 话题相关 SQL 接口
│   │   └── IDbMetaFacade.cs      // 数据库表结构查询接口 (user_tables 等)
│   ├── RecommendDbFacade.cs      // 实现：复杂推荐查询
│   ├── TopicDbFacade.cs          // 实现：话题计数 SQL
│   └── DbMetaFacade.cs           // 实现：查表名、查列名 SQL
│
├── Strategies/                   // 【策略层】封装可替换的算法
│   ├── Interfaces/
│   │   └── ISimilarityStrategy.cs// 相似度算法接口
│   └── CosineSimilarityStrategy.cs // 具体策略：余弦相似度
│
├── Infrastructure/               // 【基础设施层】底层资源管理
│   ├── IDbConnectionFactory.cs   // 数据库连接工厂接口
│   └── OracleConnectionFactory.cs// 具体工厂 (解决硬编码 new OracleConnection)
│
├── Models/                       // 【模型层】DTOs 和 数据模型
│   ├── RecommendResult.cs        // 推荐结果模型
│   ├── TopicStatResult.cs        // (新增) 话题统计结果模型
│   ├── TableMetaResult.cs        // (新增) 表结构信息模型
│   └── UserProfileResult.cs      // (新增) 用户信息模型
│
├── OracleUpdater/                // 【工具模块】(保留原有的数据生成工具)
│   ├── TestDataController.cs
│   └── TestDataService.cs
│
└── Program.cs                    // 全局配置与依赖注入 (DI)
```
重构后引入了 Infrastructure（基础设施层）、Facades（外观层） 和 Strategies（策略层），实现了高内聚低耦合的效果。
### 使用结构型模式重构
#### 使用外观模式重构
##### 1. 重构前的代码：
位置：Services/RecommendService.cs
状态：业务逻辑（RecommendTopics）与底层数据访问（OracleConnection, SQL, DataReader）完全耦合。
```
// 重构前：RecommendService.cs
using MyBackend.Models;
using Oracle.ManagedDataAccess.Client;
using Microsoft.Extensions.Configuration;

namespace MyBackend.Services;

public class RecommendService
{
    private readonly IConfiguration _config;
    public RecommendService(IConfiguration config) => _config = config;

    private OracleConnection GetConnection() 
        => new OracleConnection(_config.GetConnectionString("DefaultConnection"));

    // 问题：这里既有业务意图，又有由于 SQL 带来的巨大噪音
    public IEnumerable<RecommendResult> RecommendTopics(int userId, int topK = 4)
    {
        var results = new List<RecommendResult>();
        
        // 1. 直接依赖具体的 OracleConnection
        using var conn = GetConnection();
        conn.Open();

        // 2. 复杂的 SQL 语句直接暴露在业务层
        string sql = $@"
            SELECT * FROM (
                SELECT t.TAG_ID, t.TAG_NAME, ... (省略几十行复杂 SQL) ...
            ) WHERE ROWNUM <= {topK}";

        // 3. 繁琐的命令对象创建和参数绑定
        using var cmd = new OracleCommand(sql, conn);
        cmd.Parameters.Add(new OracleParameter("p_user_id", userId));

        // 4. 手动解析 DataReader，容易写错列名或类型
        using var reader = cmd.ExecuteReader();
        while (reader.Read())
        {
            results.Add(new RecommendResult
            {
                Topic = "#" + reader.GetString(reader.GetOrdinal("TAG_NAME")),
                Count = reader.GetInt32(reader.GetOrdinal("REAL_CNT")),
                // ... 手动映射字段
            });
        }
        return results;
    }
}
```
##### 2. 原有问题分析：
在重构前的 FoundingService 模块中，业务逻辑层（Service）与底层数据访问技术存在严重的耦合，主要体现在以下三个方面：

违反单一职责原则 (Violation of Single Responsibility Principle)：
RecommendService 类承载了过多的职责。它不仅需要处理推荐算法和业务规则的编排，还必须负责数据库连接的生命周期管理、SQL 语句的构建、参数的绑定以及 DataReader 的结果集解析。这种“全能型”类的设计导致业务逻辑与数据存取逻辑高度纠缠，降低了代码的内聚性。

紧密耦合与实现细节泄露 (Tight Coupling and Leaking Implementation Details)：
业务层直接依赖于 Oracle.ManagedDataAccess.Client 具体实现类（如 OracleConnection、OracleCommand）。SQL 语句作为硬编码字符串散落在业务方法中，导致业务层直接暴露了底层数据库的实现细节。一旦数据库表结构发生变更或更换数据库厂商，必须侵入核心业务代码进行修改，这违反了开闭原则（OCP）。

可测试性缺失 (Lack of Testability)：
由于业务类中直接实例化具体的数据库连接对象，导致无法在单元测试环境中对业务逻辑进行独立验证。测试代码被迫依赖于真实的数据库环境，这不仅降低了测试执行效率，还使得测试结果极易受外部环境（如网络波动、脏数据）影响，无法构建稳定的自动化测试体系。
##### 3. 重构的必要性：
基于上述问题，引入外观模式进行重构具有迫切的现实意义：

消除技术债务，提升可维护性：
随着系统功能的迭代，分散在各处的 `ADO.NET` 样板代码将导致系统维护成本呈指数级上升。重构能够消除重复代码，降低系统熵值，为后续功能的快速扩展奠定架构基础。

构建防腐层 (Anti-Corruption Layer)：
为了防止底层数据存储技术的复杂性向上传导并腐蚀核心业务逻辑，必须建立隔离机制。外观模式能够建立一道屏障，确保业务层只关注“获取什么数据”，而无需关心“如何获取数据”。

保障软件质量与稳定性：
为了建立健全的质量保障体系（QA），必须实现各层级的可测试性。通过重构解耦，使得针对核心算法和逻辑的单元测试成为可能，从而在开发早期发现并修复缺陷。
##### 4. 重构后的代码：
位置：
Facades/IRecommendDbFacade.cs
```
// 接口：定义了“想要什么数据”，屏蔽了“怎么取数据”
public interface IRecommendDbFacade
{
    Task<IEnumerable<RecommendResult>> FetchPersonalizedTopicsAsync(int userId, int topK);
}
```
位置：Services/RecommendService.cs
```
Facades/RecommendDbFacade.cs
// 外观实现：脏活累活全在这里做（SQL, 参数, 连接管理）
public class RecommendDbFacade : IRecommendDbFacade
{
    private readonly IDbConnectionFactory _dbFactory; // 配合工厂模式使用

    public RecommendDbFacade(IDbConnectionFactory dbFactory)
    {
        _dbFactory = dbFactory;
    }

    public async Task<IEnumerable<RecommendResult>> FetchPersonalizedTopicsAsync(int userId, int topK)
    {
        var results = new List<RecommendResult>();
        using var conn = _dbFactory.CreateConnection(); // 使用工厂创建连接
        conn.Open();

        // SQL 逻辑被安全地隔离在这里
        string sql = @"... (原有的那一大段 SQL) ...";

        using var cmd = (OracleCommand)conn.CreateCommand();
        cmd.CommandText = sql;
        cmd.Parameters.Add(new OracleParameter("p_user_id", userId));
        cmd.Parameters.Add(new OracleParameter("p_top_k", topK));

        using var reader = await cmd.ExecuteReaderAsync();
        while (await reader.ReadAsync())
        {
            // 数据映射逻辑也在这里
            results.Add(new RecommendResult { ... });
        }
        return results;
    }
}
```
位置：Services/RecommendService.cs
```
// 重构后的 Service：清爽、易读、只关注业务流
public class RecommendService
{
    private readonly IRecommendDbFacade _dbFacade;

    // 注入外观接口
    public RecommendService(IRecommendDbFacade dbFacade)
    {
        _dbFacade = dbFacade;
    }

    public async Task<IEnumerable<RecommendResult>> RecommendTopicsAsync(int userId, int topK = 4)
    {
        // 极其简洁：只调用外观接口
        // 如果这里有其他业务逻辑（比如过滤敏感词、缓存），写在这里会非常清晰
        return await _dbFacade.FetchPersonalizedTopicsAsync(userId, topK);
    }
}
```
##### 5. 重构后的收益与价值

通过引入 IRecommendDbFacade 及其实现类 RecommendDbFacade，重构后的系统在软件架构质量上获得了显著提升：

增强了模块的封装性与抽象度 (Enhanced Encapsulation and Abstraction)：
外观模式成功隐藏了底层复杂的 `ADO.NET` 操作和 SQL 交互细节。RecommendDbFacade 对外提供了一个简洁、语义明确的高层接口（如 FetchPersonalizedTopicsAsync）。业务层仅需调用该接口即可完成数据获取，极大地降低了子系统的使用门槛和认知负荷。

实现了松耦合与依赖倒置 (Loose Coupling and Dependency Inversion)：
重构后，RecommendService 不再依赖具体的 Oracle 实现，而是依赖于抽象的 IRecommendDbFacade 接口。这种设计完全符合依赖倒置原则（DIP）。未来如果需要迁移至 PostgreSQL 或 SQL Server，只需新增一个实现类并更新依赖注入配置，核心业务代码无需任何改动。

提升了代码的可测试性 (Improved Testability)：
基于接口的设计使得 Mock 技术（模拟对象）得以应用。在编写单元测试时，可以轻易地注入一个模拟的 IRecommendDbFacade 对象来返回预设数据，从而在隔离数据库环境的情况下，对 RecommendService 中的复杂业务逻辑和算法策略进行精确验证。

提高了代码的可读性与业务聚焦 (Readability and Business Focus)：
剥离了繁琐的数据访问代码后，Service 层代码行数大幅减少，结构变得清晰。开发人员在阅读业务代码时，能够直观地理解业务流程和逻辑判断，而不会被大量的底层技术细节所干扰。
#### UML类图
![](picture_1.png)
## UserAuth Service模块重构
### 使用行为型模式重构
#### 使用策略模式重构
##### 1. 重构前的代码：
在原有设计中，推荐算法的具体实现细节（如余弦相似度计算公式）被硬编码在 RecommendService 类的一个私有方法中。
位置： FoundingService/Services/RecommendService.cs
```
public class RecommendService
{
    // ... 其他依赖注入代码 ...

    public IEnumerable<object> RecommendUsers(int userId, int topN = 2)
    {
        // ... 获取数据代码 ...

        foreach (var kv in profiles)
        {
            // 问题：业务服务类直接依赖具体的算法实现
            // 如果需要修改算法（例如改为 Jaccard 相似度），必须修改此类
            double sim = CosineSim(targetProfile, kv.Value); 
            if (sim > 0) scores.Add((uid, sim));
        }

        // ... 排序和返回代码 ...
    }

    // 算法逻辑作为私有方法嵌入在 Service 中，难以复用和单独测试
    private double CosineSim(Dictionary<string, int> a, Dictionary<string, int> b)
    {
        var allKeys = a.Keys.Union(b.Keys);
        double dot = 0, normA = 0, normB = 0;
        foreach (var k in allKeys)
        {
            // ... 复杂的数学计算逻辑 ...
        }
        return (normA == 0 || normB == 0) ? 0 : dot / (Math.Sqrt(normA) * Math.Sqrt(normB));
    }
}
```
##### 2. 原有问题分析
在引入策略模式之前，RecommendService 类的设计存在以下架构缺陷：

违反开闭原则 (Violation of Open/Closed Principle)：
系统的业务逻辑与算法实现紧密耦合。若需求变更为“使用 Jaccard 系数替代余弦相似度”或“新增皮尔逊相关系数算法”，开发人员必须直接修改 RecommendService 类的源代码。这种对现有稳定代码的侵入式修改增加了引入回归错误的风险。

职责边界模糊 (Blurred Responsibility Boundaries)：
RecommendService 的核心职责应是协调数据流和执行业务规则（如过滤已关注用户、组装返回结果）。然而，原代码将复杂的数学运算逻辑嵌入其中，导致该类既是“业务编排者”又是“数学计算者”，违反了单一职责原则（SRP），增加了类的维护复杂度。

算法逻辑不可复用与不可单独测试：
由于 CosineSim 是 RecommendService 的私有方法，该算法无法被系统中的其他模块复用。同时，无法针对算法本身编写独立的单元测试，测试该算法必须构建庞大的 Service 上下文，导致测试成本过高且覆盖率不足。
##### 3. 重构的必要性
针对推荐模块的核心特性，应用策略模式进行重构具有决定性的意义：

应对算法演进的不确定性：
推荐系统是一个高度迭代的领域，相似度算法需要根据业务效果不断调整。重构消除了算法变更对业务主流程的影响，使得算法的迭代独立于业务逻辑的开发。

支持运行时动态切换：
在进行 A/B 测试时，系统可能需要根据不同的用户群组动态选择不同的相似度算法。原有的硬编码方式无法支持这一需求，而策略模式为运行时的行为切换提供了架构支持。

降低系统熵值：
随着业务发展，若在一个类中通过大量的 if-else 或 switch 语句来选择不同的算法，代码将变得极其臃肿且难以维护。策略模式通过多态机制消除了这些条件分支，保持了代码的整洁。
##### 4. 重构后的代码：
重构后，我们将算法抽象为一个独立的接口，并将具体的计算逻辑封装在单独的策略类中。RecommendService 不再关心计算细节，仅持有接口引用。
首先，定义抽象策略接口
位置：Strategies/Interfaces/ISimilarityStrategy.cs
```
public interface ISimilarityStrategy
{
    // 定义算法契约：输入两个用户画像，输出相似度分数
    double Calculate(Dictionary<string, int> userProfile, Dictionary<string, int> targetProfile);
}
```
其次，实现具体算法策略
位置：Strategies/CosineSimilarityStrategy.cs
```
public class CosineSimilarityStrategy : ISimilarityStrategy
{
    // 算法逻辑被封装在独立的类中，符合单一职责原则
    public double Calculate(Dictionary<string, int> a, Dictionary<string, int> b)
    {
        // ... 原有的余弦相似度数学计算逻辑 ...
        // (此处省略具体实现，逻辑与原私有方法一致)
        return dotProduct / (Math.Sqrt(normA) * Math.Sqrt(normB));
    }
}
```
最后，业务类可通过接口调用
位置：Services/RecommendService.cs
```
public class RecommendService
{
    private readonly ISimilarityStrategy _simStrategy;

    // 通过构造函数注入接口，实现依赖倒置
    public RecommendService(ISimilarityStrategy simStrategy, ...)
    {
        _simStrategy = simStrategy;
        // ...
    }

    public async Task<IEnumerable<object>> RecommendUsersAsync(int userId, int topN = 2)
    {
        // ...
        foreach (var kv in profiles)
        {
            // Service 只调用接口方法，不关心具体是用什么公式算的
            double sim = _simStrategy.Calculate(targetProfile, kv.Value);
            if (sim > 0) scores.Add((uid, sim));
        }
        // ...
    }
}
```
##### 5. 重构后的收益与价值
通过策略模式重构后，代码结构在以下方面获得了显著提升：

极佳的可扩展性 (Extensibility)：
新增一种推荐算法（例如 EuclideanDistanceStrategy）只需创建一个实现了 ISimilarityStrategy 接口的新类，并在依赖注入容器中进行注册即可。原有的 RecommendService 类无需修改一行代码，完美遵循了开闭原则。

提升代码的可测试性 (Testability)：
现在的算法逻辑位于独立的类中，可以编写针对 CosineSimilarityStrategy 的独立单元测试，验证各种边界条件（如向量为空、零向量等），而无需模拟复杂的数据库环境。同时，也可以向 RecommendService 注入一个 Mock 的策略对象，以验证业务流程的正确性。

增强代码的可读性与维护性 (Readability and Maintainability)：
RecommendService 的代码变得更加精简，不仅去除了复杂的数学公式，也隐藏了具体的计算细节。开发人员在阅读业务代码时，看到 _simStrategy.Calculate(...) 即可理解意图，大大降低了认知负荷。
#### UML类图
![](picture_3.png) `
### 使用创建型模式重构
#### 使用工厂方法型模式重构
##### 1. 重构前的代码
在原有设计中，数据库连接对象的创建逻辑分散在各个 Controller 和 Service 中。每个类都显式依赖于 Oracle.ManagedDataAccess.Client 库，并直接通过 new 关键字实例化具体的 OracleConnection 对象。
位置：FoundingService/Controllers/DbTestController.cs (以及其他所有涉及数据库的文件)
```
public class DbTestController : ControllerBase
{
    private readonly IConfiguration _config;

    public DbTestController(IConfiguration config)
    {
        _config = config;
    }

    [HttpGet("tables")]
    public IActionResult GetTables()
    {
        // 问题 1：重复读取配置，且硬编码连接字符串 Key ("DefaultConnection")
        var connStr = _config.GetConnectionString("DefaultConnection");

        try
        {
            // 问题 2：直接依赖具体的 OracleConnection 类
            // 导致代码与 Oracle 数据库强耦合，无法轻易切换其他数据库
            using var conn = new OracleConnection(connStr);
            conn.Open();

            // ... 后续数据库操作 ...
        }
        catch (Exception ex)
        {
            return BadRequest(new { error = ex.Message });
        }
    }
}
```
##### 2. 原有问题分析
在引入工厂模式之前，系统在资源管理和架构依赖方面存在以下显著缺陷：

高耦合度与具体实现绑定 (High Coupling to Concrete Implementation)：
系统中的多个模块（Controller、Service）直接引用了 Oracle.ManagedDataAccess.Client 命名空间并实例化 OracleConnection。这种强耦合导致整个应用程序被锁定在 Oracle 数据库上。若未来需要迁移至 PostgreSQL 或 SQL Server，必须对所有涉及数据库操作的源文件进行逐一修改，修改成本极高。

违反依赖倒置原则 (Violation of Dependency Inversion Principle)：
高层业务模块依赖于低层的数据驱动实现细节，而非依赖于抽象接口（IDbConnection）。这使得系统架构呈现为倒金字塔结构，底层实现的变动极易波及上层逻辑。

配置管理分散与重复 (Scattered Configuration Management)：
获取连接字符串的代码 _config.GetConnectionString(...) 重复出现在每一个 Controller 中。这不仅违反了 DRY（Don't Repeat Yourself）原则，还增加了出错的风险（例如在不同地方使用了不同的连接字符串 Key）。
##### 3. 重构的必要性
针对基础设施层的稳定性与扩展性，应用工厂方法模式进行重构是必要的：

支持异构数据库环境：
在企业级应用演进过程中，可能会面临数据库去 IOE（去 Oracle 化）或根据业务场景分库（如部分数据存 MySQL）的需求。重构为工厂模式是实现平滑迁移的前提条件。

统一资源管控：
数据库连接是昂贵的系统资源。通过工厂模式统一接管连接的创建过程，未来可以在工厂内部方便地添加连接池预热、连接监控、多租户动态切换连接字符串等高级功能，而无需修改业务代码。
##### 4. 重构后的代码
重构后，我们将“如何创建数据库连接”的责任委托给了一个专门的工厂接口及其实现类。业务代码不再感知具体的数据库驱动。
首先，定义抽象工厂接口
位置：Infrastructure/IDbConnectionFactory.cs
```
using System.Data;

public interface IDbConnectionFactory
{
    // 定义契约：工厂负责生产一个抽象的 IDbConnection 对象
    // 具体的返回类型（如 OracleConnection）被隐藏在接口之后
    IDbConnection CreateConnection();
}
```
然后，实现具体工厂
位置：Infrastructure/OracleConnectionFactory.cs
```
using System.Data;
using Oracle.ManagedDataAccess.Client;

public class OracleConnectionFactory : IDbConnectionFactory
{
    private readonly string _connectionString;

    public OracleConnectionFactory(IConfiguration config)
    {
        // 集中管理配置读取逻辑
        _connectionString = config.GetConnectionString("DefaultConnection");
    }

    public IDbConnection CreateConnection()
    {
        // 封装具体实例化逻辑
        return new OracleConnection(_connectionString);
    }
}
```
最后，消费端通过接口调用
位置：Facades/RecommendDbFacade.cs
```
public class RecommendDbFacade : IRecommendDbFacade
{
    private readonly IDbConnectionFactory _dbFactory;

    // 依赖注入：注入抽象工厂接口，而非具体类
    public RecommendDbFacade(IDbConnectionFactory dbFactory)
    {
        _dbFactory = dbFactory;
    }

    public async Task<IEnumerable<RecommendResult>> FetchPersonalizedTopicsAsync(...)
    {
        // 消费端只管“我要一个连接”，不关心是 Oracle 还是 MySQL
        using var conn = _dbFactory.CreateConnection(); 
        conn.Open();
        
        // ... 后续操作 ...
    }
}
```
##### 5. 重构后的收益与价值
通过工厂方法模式重构后，系统在以下方面获得了显著提升：

极高的可维护性与集中化管理 (Centralized Management)：
所有与数据库连接创建相关的逻辑（包括配置读取、驱动加载）都被限制在 OracleConnectionFactory 这一个类中。任何关于连接配置的变更（如修改密码获取方式、更改连接超时设置）只需在一个文件中修改，即可全局生效。

无缝的数据库切换能力 (Seamless Database Switching)：
若需更换数据库，只需新增一个实现了 IDbConnectionFactory 的类（例如 MySqlConnectionFactory），并在 Program.cs 的依赖注入配置中替换注册即可。原有庞大的业务代码库无需任何改动，极大地降低了技术转型的风险。

提升单元测试的灵活性 (Improved Unit Testing)：
在编写单元测试时，可以通过 Mock 框架轻松模拟 IDbConnectionFactory 接口，使其返回一个模拟的数据库连接对象（如内存数据库连接或 Mock 对象）。这彻底解决了测试代码依赖真实数据库环境的痛点。
#### UML类图
![](picture_4.png)
#### 使用单例模式重构
##### 1. 重构前的代码
在重构前的设计中，或者在错误的依赖注入配置下，无状态的工具类（如算法策略）或配置类（如连接工厂）被配置为瞬时模式 (Transient) 或作用域模式 (Scoped)。这意味着每次发生 HTTP 请求，甚至在同一次请求中实现每次注入时，都会创建一个新的对象实例。
位置：FoundingService/Program.cs (服务注册逻辑)
```
// 重构前：低效的生命周期管理
var builder = WebApplication.CreateBuilder(args);

// ... 其他配置 ...

// 问题：AddTransient 表示每次请求都会创建一个新的实例
// 对于 OracleConnectionFactory，这意味着每次都要重新读取配置文件
builder.Services.AddTransient<IDbConnectionFactory, OracleConnectionFactory>();

// 问题：CosineSimilarityStrategy 是纯数学计算，完全无状态
// 创建成千上万个该对象实例是对内存的无谓浪费
builder.Services.AddTransient<ISimilarityStrategy, CosineSimilarityStrategy>();
```
##### 2. 原有问题分析
在使用瞬时模式（Transient）处理无状态对象时，系统存在以下性能与资源管理层面的问题：

内存资源浪费与垃圾回收压力 (Memory Waste and GC Pressure)：
CosineSimilarityStrategy 等类仅包含方法逻辑，不包含成员变量。如果采用瞬时模式，在高并发场景下（例如每秒 1000 次请求），运行时环境将每秒分配 1000 个对象的内存空间，并在请求结束后销毁。这会导致托管堆（Managed Heap）内存碎片化，频繁触发垃圾回收（Garbage Collection），从而造成 CPU 抖动。

冗余的初始化开销 (Redundant Initialization Overhead)：
OracleConnectionFactory 在构造时需要读取 IConfiguration 以获取连接字符串。若配置为瞬时模式，每次数据库操作前都会重复执行配置读取和字符串解析逻辑。虽然单次开销微小，但在大规模并发下，这种累积的 I/O 或计算开销是不容忽视的性能损耗。

状态不一致风险 (Risk of State Inconsistency)：
虽然当前工厂是无状态的，但如果未来引入了“连接池指标监控”或“全局熔断计数器”等需要跨请求共享的状态，瞬时模式将导致每个请求拥有独立的计数器，无法实现全局统筹，从而导致业务逻辑错误。
##### 3. 重构的必要性
针对高并发 Web API 的特性，应用单例模式进行重构是必要的：

契合无状态组件的本质：
策略模式中的算法类、工厂模式中的工厂类，本质上都是“功能提供者”而非“数据持有者”。对于此类组件，单例模式是其在内存中最自然的映射形式。

提升系统吞吐量：
减少对象创建和销毁的频率，能够显著降低 .NET 运行时的负担，使服务器能够将更多的 CPU 算力用于处理核心业务逻辑，从而提升整体的 TPS（每秒事务处理量）。
##### 4. 重构后的代码
重构后，我们将这些无状态（Stateless）且线程安全（Thread-Safe）的组件注册为 单例 (Singleton)。在整个应用程序的生命周期内，容器只会在第一次被调用时实例化一次，之后所有请求共享同一个实例。
位置： FoundingService/Program.cs
```
// 重构后：高效的单例模式应用
var builder = WebApplication.CreateBuilder(args);

// ... 其他配置 ...

// 优化 1：数据库连接工厂被注册为单例
// 理由：工厂只包含连接字符串配置，属于全局共享资源，无需重复创建
builder.Services.AddSingleton<IDbConnectionFactory, OracleConnectionFactory>();

// 优化 2：相似度策略被注册为单例
// 理由：该类仅包含纯函数逻辑，不持有任何状态，全局共享一个实例极其高效
builder.Services.AddSingleton<ISimilarityStrategy, CosineSimilarityStrategy>();
```
##### 5. 重构后的收益与价值
通过依赖注入容器实现单例模式后，系统架构获得如下收益：

显著的内存优化 (Significant Memory Optimization)：
无论系统运行多久、并发量多高，OracleConnectionFactory 和 CosineSimilarityStrategy 在内存中永远只占用一份空间。这对于长期运行的服务端应用至关重要，有效降低了内存泄漏的风险。

全局配置的一致性 (Consistency of Global Configuration)：
单例模式确保了 OracleConnectionFactory 在应用启动时一次性加载配置。这不仅提升了性能，还保证了在应用运行期间，所有组件使用的连接配置是严格一致的，避免了因配置热加载导致的瞬时不一致问题。

线程安全的最佳实践 (Thread-Safety Best Practices)：
采用单例模式强制开发者在编写底层组件（如策略和工厂）时必须考虑线程安全问题（因为多线程会访问同一实例）。这在架构层面反向促进了代码质量的提升，避免了在服务类中引入非必要的共享状态。
#### UML类图
![](picture_5.png)
### 使用其他架构模式重构
#### 使用依赖注入模式重构
##### 1. 重构前的代码
在重构前的代码中，类与其依赖项之间存在“硬编码”的强耦合关系。对象不仅负责执行业务逻辑，还负责创建其依赖对象的实例（即“控制反转”之前的状态）。
位置：Services/RecommendService.cs (依赖方)
```
public class RecommendService
{
    private readonly IConfiguration _config;

    public RecommendService(IConfiguration config)
    {
        _config = config;
    }

    public IEnumerable<RecommendResult> RecommendTopics(int userId)
    {
        // 问题 1：直接实例化具体类 (Direct Instantiation)
        // Service 类“知道”过多关于数据库驱动的细节。
        // “new”关键字将代码与 Oracle.ManagedDataAccess 锁死。
        using var conn = new OracleConnection(_config.GetConnectionString("DefaultConnection"));
        
        // 问题 2：硬编码算法逻辑
        // 在这里直接编写具体的算法实现，而非依赖抽象。
        double score = CosineSim(...); 
    }
}
```
位置：
Controllers/RecommendController.cs (调用方)
虽然原代码中使用了简单的构造函数注入，但在没有统一 DI 容器规划的情况下，经常出现以下反模式：
```
public class RecommendController : ControllerBase
{
    // 常见反模式：在 Controller 内部手动 new Service
    // 或者虽然注入了 Service，但 Service 内部全是 new
    private readonly RecommendService _service;

    public RecommendController()
    {
        // 假设没有配置 DI 容器，往往需要手动创建整个依赖链
        var config = new ConfigurationBuilder().Build();
        _service = new RecommendService(config); 
    }
}
```
##### 2. 原有问题分析
在未全面贯彻依赖注入模式之前，系统架构存在以下核心缺陷：

紧密耦合导致的僵化：
当 RecommendService 内部直接 new OracleConnection() 时，它就与 Oracle 数据库实现产生了物理上的编译期依赖。如果不修改 Service 的源代码，就无法将数据库替换为 Mock 对象或 SQL Server。这种“牵一发而动全身”的依赖链使得代码难以修改。

无法进行单元测试：
单元测试的核心在于“隔离”。由于被测对象（System Under Test）自行创建了依赖项，测试框架无法介入并替换这些依赖项。要测试 RecommendService，必须配置真实的数据库环境。这导致测试变成了缓慢且不稳定的集成测试，而非快速反馈的单元测试。

对象生命周期管理混乱：
在手动创建对象（new）的模式下，开发者必须时刻警惕对象的销毁（Dispose）。如果在复杂的调用链中忘记释放数据库连接或文件句柄，将导致严重的资源泄漏（Resource Leak）。
##### 3. 重构的必要性
依赖注入是现代企业级应用架构的基石，其重构必要性体现在：

实现控制反转 (Inversion of Control, IoC)：
将“谁来创建对象”的控制权，从业务逻辑类中剥离，移交给框架（容器）。这是解耦最彻底的手段。

支持并行开发：
一旦定义好接口（如 IRecommendDbFacade），负责 Service 的开发人员和负责数据库实现的开发人员可以并行工作。Service 开发人员无需等待数据库代码写完，只需针对接口编程即可。
##### 4. 重构后的代码
重构后，我们全面应用构造函数注入（Constructor Injection）。类不再负责创建依赖，而是通过构造函数声明它“需要”什么。对象的创建和组装职责移交给了 `ASP.NET Core` 的 IoC 容器。
位置：Services/RecommendService.cs (被注入接口)
```
public class RecommendService
{
    // 声明依赖接口，而非具体类
    private readonly IRecommendDbFacade _dbFacade;
    private readonly ISimilarityStrategy _simStrategy;

    // 构造函数注入：由外部容器传入实例
    public RecommendService(IRecommendDbFacade dbFacade, ISimilarityStrategy simStrategy)
    {
        _dbFacade = dbFacade;
        _simStrategy = simStrategy;
    }

    public async Task<IEnumerable<RecommendResult>> RecommendTopicsAsync(int userId)
    {
        // 使用注入的对象，完全不关心它们是如何创建的
        return await _dbFacade.FetchPersonalizedTopicsAsync(userId, 4);
    }
}
```
位置：Program.cs (组装根 / Composition Root)
```
var builder = WebApplication.CreateBuilder(args);

// 在容器中注册依赖关系图谱
// 容器将负责解析：RecommendController -> RecommendService -> IRecommendDbFacade -> IDbConnectionFactory
builder.Services.AddSingleton<IDbConnectionFactory, OracleConnectionFactory>();
builder.Services.AddScoped<IRecommendDbFacade, RecommendDbFacade>();
builder.Services.AddSingleton<ISimilarityStrategy, CosineSimilarityStrategy>();
builder.Services.AddScoped<RecommendService>();
```
##### 5. 重构后的收益与价值
通过依赖注入模式重构后，代码质量在以下维度实现了质的飞跃：

极高的可测试性 (Superior Testability)：
这是 DI 带来的最大红利。在测试 RecommendService 时，可以轻松注入一个 Mock<IRecommendDbFacade>。
* 场景：测试“当数据库返回空列表时，Service 是否报错”。
* 实现：无需造假数据，只需配置 `Mock` 对象 `Setup(f => f.Fetch...).Returns(EmptyList)` 即可验证逻辑。

代码结构清晰与关注点分离 (Clean Architecture)：
RecommendService 的构造函数清晰地列出了它的“合作者”。阅读代码的人一眼就能看出该类需要什么资源才能工作，而不需要深入每一行代码去寻找隐藏的 new 关键字。

统一的生命周期管理 (Managed Lifecycle)：
DI 容器接管了对象的生死。
* 配置为 AddScoped 的数据库外观类，会在 HTTP 请求结束时自动被容器调用 Dispose 方法，释放数据库连接。
* 开发人员不再需要担心资源未释放的问题，从根本上杜绝了部分内存泄漏隐患。

灵活的配置与替换 (Configurability)：
如果需要将相似度算法从 Cosine 切换为 Jaccard，或者将数据库从 Oracle 切换为 PostgreSQL，只需在 Program.cs 中修改一行注册代码。整个应用程序的其余部分无需任何改动及重新编译，极大地提升了系统的可维护性。
#### UML类图
![](picture_6.png)
#### 使用数据传输对象重构
##### 1. 重构前的代码
在原有代码中，控制器和部分服务方法频繁使用匿名类型 (Anonymous Types) 和弱类型集合 (`List<object>`) 来承载和返回数据。数据结构仅在运行时通过 JSON 序列化体现，编译期无法确知其结构。
位置：Controllers/DbTestController.cs
```
[HttpGet("columns")]
public IActionResult GetColumns([FromQuery] string table)
{
    // 问题 1：使用 List<object>，丢失了类型信息
    var columns = new List<object>(); 

    try
    {
        // ... 数据库连接代码 ...
        while (reader.Read())
        {
            // 问题 2：使用匿名对象 (new { ... })
            // 该对象无法作为参数传递给其他方法，也无法被 Swagger 识别生成文档
            columns.Add(new {
                ColumnName = reader.GetString(0),
                DataType   = reader.GetString(1),
                Length     = reader.GetInt32(2),
                Nullable   = reader.GetString(3)
            });
        }
    }
    catch (Exception ex)
    {
        return BadRequest(new { error = ex.Message });
    }

    // 返回的是通用的 JSON，前端开发人员必须查看代码才知道里面有哪些字段
    return Ok(new { table, columns });
}
```
##### 2. 原有问题分析
在未引入 DTO 模式之前，系统的数据交互层存在以下显著缺陷：

API 契约模糊 (Ambiguous API Contract):
由于使用了 object 或 dynamic 返回类型，```ASP.NET Core``` 的 Swagger/OpenAPI 工具无法自动生成数据模型文档。前端开发人员无法通过 API 文档得知接口返回的具体字段名称和类型，必须依赖口头沟通或阅读后端源代码，增加了协作成本和集成错误的风险。

类型安全缺失 (Lack of Type Safety):
匿名类型的作用域仅限于当前方法。如果试图将查询结果传递给另一个辅助方法进行处理（例如数据清洗或格式化），必须将其转换为 dynamic 或使用反射，这使得编译器失去了类型检查能力，极易在运行时引发 RuntimeBinderException。

序列化行为不可控 (Uncontrollable Serialization):
匿名类型的属性名称即为最终 JSON 的字段名。如果数据库字段名为 COLUMN_NAME，而代码中写的匿名属性也是 COLUMN_NAME，那么返回给前端的 JSON 就是全大写。若前端规范要求小写驼峰（camelCase），使用匿名对象很难在不修改查询代码的情况下灵活调整序列化规则。
##### 3. 重构的必要性
为了构建健壮、易于维护且对前端友好的 Web API，引入 DTO 模式是必要的：

解耦领域模型与表现层：
DTO 在数据库表结构（Schema）和 API 返回格式之间建立了一个缓冲层。即使数据库底层的列名发生变更，或内部数据存储方式改变，只需在 DTO 映射层进行调整，无需破坏对外暴露的 API 接口格式。

支持自动化文档生成：
现代 API 开发高度依赖自动化工具。明确的 DTO 类是 Swagger 等工具生成 Standard OpenAPI Specification 文档的基础，是前后端分离开发模式下的标准实践。
##### 4. 重构后的代码
重构后，我们定义了显式的 DTO 类。这些类是纯粹的数据容器，没有任何行为，专门用于在层与层之间传输数据以及生成明确的 API 契约。
首先，定义DTO类
位置：Models/TableMetaResult.cs
```
namespace MyBackend.Models;

public class TableMetaResult
{
    // 显式定义的属性，类型明确
    public string ColumnName { get; set; } = "";
    public string DataType { get; set; } = "";
    public int Length { get; set; }
    public string Nullable { get; set; } = "";
}
```
其次，使用DTO进行数据传输
位置：Facades/DbMetaFacade.cs (及 Controller)
```
// 方法签名明确返回 IEnumerable<TableMetaResult>
public async Task<IEnumerable<TableMetaResult>> FetchTableColumnsAsync(string tableName)
{
    var columns = new List<TableMetaResult>(); // 强类型集合

    // ... 数据库操作 ...
    while (await reader.ReadAsync())
    {
        // 实例化具体的 DTO 对象
        columns.Add(new TableMetaResult
        {
            ColumnName = reader.GetString(0),
            DataType = reader.GetString(1),
            Length = reader.GetInt32(2),
            Nullable = reader.GetString(3)
        });
    }
    return columns;
}
```
##### 5. 重构后的收益与价值
通过 DTO 模式重构后，代码质量和系统交互体验获得了以下提升：

编译期类型检查 (Compile-Time Type Checking)：
代码具备了强类型特征。开发人员在使用 `TableMetaResult` 对象时，IDE（如 Visual Studio）可以提供完整的智能感知（IntelliSense）。如果拼写错误（如将 Length 拼成 Lenth），编译器会立即报错，而不是等到运行时才崩溃。

清晰且自动化的 API 文档 (Clear and Automated Documentation) Swagger UI 能够直接展示 `TableMetaResult` 的结构，明确指出 `Length` 是 integer 类型，`Nullable` 是 string 类型。前端开发人员可以据此自动生成 TypeScript 客户端代码，极大提升了开发效率。

灵活的序列化控制 (Flexible Serialization Control)：
可以在 DTO 类上使用特性（Attributes）来精细控制序列化行为。例如，使用 `[JsonPropertyName("col_len")]` 可以将属性 `Length` 序列化为 `col_len`，从而在保持 C# 代码规范（PascalCase）的同时，满足前端特定的命名规范（Snake_case），实现了内部实现与外部接口的优雅分离。
#### UML类图
![](picture_7.png)
## 重构后的交互图
![](picture_2.png)